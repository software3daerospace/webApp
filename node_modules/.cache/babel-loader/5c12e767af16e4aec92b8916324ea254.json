{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.positionFromDate = exports.startsBefore = undefined;\n\nvar _event2 = require('./event');\n\nObject.defineProperty(exports, 'startsBefore', {\n  enumerable: true,\n  get: function get() {\n    return _event2.startsBefore;\n  }\n});\nObject.defineProperty(exports, 'positionFromDate', {\n  enumerable: true,\n  get: function get() {\n    return _event2.positionFromDate;\n  }\n});\n\nvar _sortBy = require('lodash/sortBy');\n\nvar _sortBy2 = _interopRequireDefault(_sortBy);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n/**\n * Return true if event a and b is considered to be on the same row.\n */\n\n\nfunction onSameRow(a, b) {\n  return (// Occupies the same start slot.\n    Math.abs(b.startSlot - a.startSlot) <= 30 || // A's start slot overlaps with b's end slot.\n    a.startSlot > b.startSlot && a.startSlot < b.endSlot\n  );\n}\n\nfunction sortByRender(events) {\n  var sortedByTime = (0, _sortBy2.default)(events, ['start', function (e) {\n    return -e.end;\n  }]);\n  var sorted = [];\n\n  while (sortedByTime.length > 0) {\n    var event = sortedByTime.shift();\n    sorted.push(event);\n\n    for (var i = 0; i < sortedByTime.length; i++) {\n      var test = sortedByTime[i]; // Still inside this event, look for next.\n\n      if (event.end > test.start) {\n        continue;\n      } // We've found the first event of the next event group.\n      // If that event is not right next to our current event, we have to\n      // move it here.\n\n\n      if (i > 0) {\n        var _sortedByTime$splice = sortedByTime.splice(i, 1),\n            _event = _sortedByTime$splice[0];\n\n        sorted.push(_event);\n      } // We've already found the next event group, so stop looking.\n\n\n      break;\n    }\n  }\n\n  return sorted;\n}\n\nfunction getStyledEvents(_ref) {\n  var events = _ref.events,\n      props = _objectWithoutProperties(_ref, ['events']); // Create proxy events and order them so that we don't have\n  // to fiddle with z-indexes.\n\n\n  var proxies = events.map(function (event) {\n    return new _event2.Event(event, props);\n  });\n  var eventsInRenderOrder = sortByRender(proxies); // Group overlapping events, while keeping order.\n  // Every event is always one of: container, row or leaf.\n  // Containers can contain rows, and rows can contain leaves.\n\n  var containerEvents = [];\n\n  var _loop = function _loop(i) {\n    var event = eventsInRenderOrder[i]; // Check if this event can go into a container event.\n\n    var container = containerEvents.find(function (c) {\n      return c.endSlot > event.startSlot;\n    }); // Couldn't find a container — that means this event is a container.\n\n    if (!container) {\n      event.rows = [];\n      containerEvents.push(event);\n      return 'continue';\n    } // Found a container for the event.\n\n\n    event.container = container; // Check if the event can be placed in an existing row.\n    // Start looking from behind.\n\n    var row = null;\n\n    for (var j = container.rows.length - 1; !row && j >= 0; j--) {\n      if (onSameRow(container.rows[j], event)) {\n        row = container.rows[j];\n      }\n    }\n\n    if (row) {\n      // Found a row, so add it.\n      row.leaves.push(event);\n      event.row = row;\n    } else {\n      // Couldn't find a row – that means this event is a row.\n      event.leaves = [];\n      container.rows.push(event);\n    }\n  };\n\n  for (var i = 0; i < eventsInRenderOrder.length; i++) {\n    var _ret = _loop(i);\n\n    if (_ret === 'continue') continue;\n  } // Return the original events, along with their styles.\n\n\n  return eventsInRenderOrder.map(function (event) {\n    return {\n      event: event.data,\n      style: {\n        top: event.top,\n        height: event.height,\n        width: event.width,\n        xOffset: event.xOffset\n      }\n    };\n  });\n}\n\nexports.default = getStyledEvents;","map":{"version":3,"sources":["/home/software/software/app/3daerospace_App/node_modules/react-big-calendar/lib/utils/dayViewLayout/index.js"],"names":["exports","__esModule","positionFromDate","startsBefore","undefined","_event2","require","Object","defineProperty","enumerable","get","_sortBy","_sortBy2","_interopRequireDefault","obj","default","_objectWithoutProperties","keys","target","i","indexOf","prototype","hasOwnProperty","call","onSameRow","a","b","Math","abs","startSlot","endSlot","sortByRender","events","sortedByTime","e","end","sorted","length","event","shift","push","test","start","_sortedByTime$splice","splice","_event","getStyledEvents","_ref","props","proxies","map","Event","eventsInRenderOrder","containerEvents","_loop","container","find","c","rows","row","j","leaves","_ret","data","style","top","height","width","xOffset"],"mappings":"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","sourcesContent":["'use strict';\n\nexports.__esModule = true;\nexports.positionFromDate = exports.startsBefore = undefined;\n\nvar _event2 = require('./event');\n\nObject.defineProperty(exports, 'startsBefore', {\n  enumerable: true,\n  get: function get() {\n    return _event2.startsBefore;\n  }\n});\nObject.defineProperty(exports, 'positionFromDate', {\n  enumerable: true,\n  get: function get() {\n    return _event2.positionFromDate;\n  }\n});\n\nvar _sortBy = require('lodash/sortBy');\n\nvar _sortBy2 = _interopRequireDefault(_sortBy);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\n/**\n * Return true if event a and b is considered to be on the same row.\n */\nfunction onSameRow(a, b) {\n  return (\n    // Occupies the same start slot.\n    Math.abs(b.startSlot - a.startSlot) <= 30 ||\n    // A's start slot overlaps with b's end slot.\n    a.startSlot > b.startSlot && a.startSlot < b.endSlot\n  );\n}\n\nfunction sortByRender(events) {\n  var sortedByTime = (0, _sortBy2.default)(events, ['start', function (e) {\n    return -e.end;\n  }]);\n\n  var sorted = [];\n  while (sortedByTime.length > 0) {\n    var event = sortedByTime.shift();\n    sorted.push(event);\n\n    for (var i = 0; i < sortedByTime.length; i++) {\n      var test = sortedByTime[i];\n\n      // Still inside this event, look for next.\n      if (event.end > test.start) {\n        continue;\n      }\n\n      // We've found the first event of the next event group.\n      // If that event is not right next to our current event, we have to\n      // move it here.\n      if (i > 0) {\n        var _sortedByTime$splice = sortedByTime.splice(i, 1),\n            _event = _sortedByTime$splice[0];\n\n        sorted.push(_event);\n      }\n\n      // We've already found the next event group, so stop looking.\n      break;\n    }\n  }\n\n  return sorted;\n}\n\nfunction getStyledEvents(_ref) {\n  var events = _ref.events,\n      props = _objectWithoutProperties(_ref, ['events']);\n\n  // Create proxy events and order them so that we don't have\n  // to fiddle with z-indexes.\n  var proxies = events.map(function (event) {\n    return new _event2.Event(event, props);\n  });\n  var eventsInRenderOrder = sortByRender(proxies);\n\n  // Group overlapping events, while keeping order.\n  // Every event is always one of: container, row or leaf.\n  // Containers can contain rows, and rows can contain leaves.\n  var containerEvents = [];\n\n  var _loop = function _loop(i) {\n    var event = eventsInRenderOrder[i];\n\n    // Check if this event can go into a container event.\n    var container = containerEvents.find(function (c) {\n      return c.endSlot > event.startSlot;\n    });\n\n    // Couldn't find a container — that means this event is a container.\n    if (!container) {\n      event.rows = [];\n      containerEvents.push(event);\n      return 'continue';\n    }\n\n    // Found a container for the event.\n    event.container = container;\n\n    // Check if the event can be placed in an existing row.\n    // Start looking from behind.\n    var row = null;\n    for (var j = container.rows.length - 1; !row && j >= 0; j--) {\n      if (onSameRow(container.rows[j], event)) {\n        row = container.rows[j];\n      }\n    }\n\n    if (row) {\n      // Found a row, so add it.\n      row.leaves.push(event);\n      event.row = row;\n    } else {\n      // Couldn't find a row – that means this event is a row.\n      event.leaves = [];\n      container.rows.push(event);\n    }\n  };\n\n  for (var i = 0; i < eventsInRenderOrder.length; i++) {\n    var _ret = _loop(i);\n\n    if (_ret === 'continue') continue;\n  }\n\n  // Return the original events, along with their styles.\n  return eventsInRenderOrder.map(function (event) {\n    return {\n      event: event.data,\n      style: {\n        top: event.top,\n        height: event.height,\n        width: event.width,\n        xOffset: event.xOffset\n      }\n    };\n  });\n}\n\nexports.default = getStyledEvents;"]},"metadata":{},"sourceType":"script"}