{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.Event = undefined;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nexports.startsBefore = startsBefore;\nexports.positionFromDate = positionFromDate;\n\nvar _accessors = require('../accessors');\n\nvar _dates = require('../dates');\n\nvar _dates2 = _interopRequireDefault(_dates);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction startsBefore(date, min) {\n  return _dates2.default.lt(_dates2.default.merge(min, date), min, 'minutes');\n}\n\nfunction positionFromDate(date, min, total) {\n  if (startsBefore(date, min)) {\n    return 0;\n  }\n\n  var diff = _dates2.default.diff(min, _dates2.default.merge(min, date), 'minutes');\n\n  return Math.min(diff, total);\n}\n\nvar Event = exports.Event = function () {\n  function Event(data, props) {\n    _classCallCheck(this, Event);\n\n    var startAccessor = props.startAccessor,\n        endAccessor = props.endAccessor,\n        min = props.min,\n        totalMin = props.totalMin;\n\n    var _normalizeDates = normalizeDates((0, _accessors.accessor)(data, startAccessor), (0, _accessors.accessor)(data, endAccessor), props),\n        startDate = _normalizeDates[0],\n        endDate = _normalizeDates[1];\n\n    this.startSlot = positionFromDate(startDate, min, totalMin);\n    this.endSlot = positionFromDate(endDate, min, totalMin);\n    this.start = +startDate;\n    this.end = +endDate;\n    this.top = this.startSlot / totalMin * 100;\n    this.height = this.endSlot / totalMin * 100 - this.top;\n    this.data = data;\n  }\n  /**\n   * The event's width without any overlap.\n   */\n\n\n  _createClass(Event, [{\n    key: '_width',\n    get: function get() {\n      // The container event's width is determined by the maximum number of\n      // events in any of its rows.\n      if (this.rows) {\n        var columns = this.rows.reduce(function (max, row) {\n          return Math.max(max, row.leaves.length + 1); // add itself\n        }, 0) + 1; // add the container\n\n        return 100 / columns;\n      }\n\n      var availableWidth = 100 - this.container._width; // The row event's width is the space left by the container, divided\n      // among itself and its leaves.\n\n      if (this.leaves) {\n        return availableWidth / (this.leaves.length + 1);\n      } // The leaf event's width is determined by its row's width\n\n\n      return this.row._width;\n    }\n    /**\n     * The event's calculated width, possibly with extra width added for\n     * overlapping effect.\n     */\n\n  }, {\n    key: 'width',\n    get: function get() {\n      var noOverlap = this._width;\n      var overlap = Math.min(100, this._width * 1.7); // Containers can always grow.\n\n      if (this.rows) {\n        return overlap;\n      } // Rows can grow if they have leaves.\n\n\n      if (this.leaves) {\n        return this.leaves.length > 0 ? overlap : noOverlap;\n      } // Leaves can grow unless they're the last item in a row.\n\n\n      var leaves = this.row.leaves;\n      var index = leaves.indexOf(this);\n      return index === leaves.length - 1 ? noOverlap : overlap;\n    }\n  }, {\n    key: 'xOffset',\n    get: function get() {\n      // Containers have no offset.\n      if (this.rows) {\n        return 0;\n      } // Rows always start where their container ends.\n\n\n      if (this.leaves) {\n        return this.container._width;\n      } // Leaves are spread out evenly on the space left by its row.\n\n\n      var _row = this.row,\n          leaves = _row.leaves,\n          xOffset = _row.xOffset,\n          _width = _row._width;\n      var index = leaves.indexOf(this) + 1;\n      return xOffset + index * _width;\n    }\n  }]);\n\n  return Event;\n}();\n/**\n * Return start and end dates with respect to timeslot positions.\n */\n\n\nfunction normalizeDates(startDate, endDate, _ref) {\n  var min = _ref.min,\n      showMultiDayTimes = _ref.showMultiDayTimes;\n\n  if (!showMultiDayTimes) {\n    return [startDate, endDate];\n  }\n\n  var current = new Date(min); // today at midnight\n\n  var c = new Date(current);\n  var s = new Date(startDate);\n  var e = new Date(endDate); // Use noon to compare dates to avoid DST issues.\n\n  s.setHours(12, 0, 0, 0);\n  e.setHours(12, 0, 0, 0);\n  c.setHours(12, 0, 0, 0); // Current day is at the start, but it spans multiple days,\n  // so we correct the end.\n\n  if (+c === +s && c < e) {\n    return [startDate, _dates2.default.endOf(startDate, 'day')];\n  } // Current day is in between start and end dates,\n  // so we make it span all day.\n\n\n  if (c > s && c < e) {\n    return [current, _dates2.default.endOf(current, 'day')];\n  } // Current day is at the end of a multi day event,\n  // so we make it start at midnight, and end normally.\n\n\n  if (c > s && +c === +e) {\n    return [current, endDate];\n  }\n\n  return [startDate, endDate];\n}","map":{"version":3,"sources":["/home/software/software/app/3daerospace_App/node_modules/react-big-calendar/lib/utils/dayViewLayout/event.js"],"names":["exports","__esModule","Event","undefined","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","startsBefore","positionFromDate","_accessors","require","_dates","_dates2","_interopRequireDefault","obj","default","_classCallCheck","instance","TypeError","date","min","lt","merge","total","diff","Math","data","startAccessor","endAccessor","totalMin","_normalizeDates","normalizeDates","accessor","startDate","endDate","startSlot","endSlot","start","end","top","height","get","rows","columns","reduce","max","row","leaves","availableWidth","container","_width","noOverlap","overlap","index","indexOf","_row","xOffset","_ref","showMultiDayTimes","current","Date","c","s","e","setHours","endOf"],"mappings":"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","sourcesContent":["'use strict';\n\nexports.__esModule = true;\nexports.Event = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.startsBefore = startsBefore;\nexports.positionFromDate = positionFromDate;\n\nvar _accessors = require('../accessors');\n\nvar _dates = require('../dates');\n\nvar _dates2 = _interopRequireDefault(_dates);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction startsBefore(date, min) {\n  return _dates2.default.lt(_dates2.default.merge(min, date), min, 'minutes');\n}\n\nfunction positionFromDate(date, min, total) {\n  if (startsBefore(date, min)) {\n    return 0;\n  }\n\n  var diff = _dates2.default.diff(min, _dates2.default.merge(min, date), 'minutes');\n  return Math.min(diff, total);\n}\n\nvar Event = exports.Event = function () {\n  function Event(data, props) {\n    _classCallCheck(this, Event);\n\n    var startAccessor = props.startAccessor,\n        endAccessor = props.endAccessor,\n        min = props.min,\n        totalMin = props.totalMin;\n\n    var _normalizeDates = normalizeDates((0, _accessors.accessor)(data, startAccessor), (0, _accessors.accessor)(data, endAccessor), props),\n        startDate = _normalizeDates[0],\n        endDate = _normalizeDates[1];\n\n    this.startSlot = positionFromDate(startDate, min, totalMin);\n    this.endSlot = positionFromDate(endDate, min, totalMin);\n    this.start = +startDate;\n    this.end = +endDate;\n    this.top = this.startSlot / totalMin * 100;\n    this.height = this.endSlot / totalMin * 100 - this.top;\n    this.data = data;\n  }\n\n  /**\n   * The event's width without any overlap.\n   */\n\n\n  _createClass(Event, [{\n    key: '_width',\n    get: function get() {\n      // The container event's width is determined by the maximum number of\n      // events in any of its rows.\n      if (this.rows) {\n        var columns = this.rows.reduce(function (max, row) {\n          return Math.max(max, row.leaves.length + 1); // add itself\n        }, 0) + 1; // add the container\n\n        return 100 / columns;\n      }\n\n      var availableWidth = 100 - this.container._width;\n\n      // The row event's width is the space left by the container, divided\n      // among itself and its leaves.\n      if (this.leaves) {\n        return availableWidth / (this.leaves.length + 1);\n      }\n\n      // The leaf event's width is determined by its row's width\n      return this.row._width;\n    }\n\n    /**\n     * The event's calculated width, possibly with extra width added for\n     * overlapping effect.\n     */\n\n  }, {\n    key: 'width',\n    get: function get() {\n      var noOverlap = this._width;\n      var overlap = Math.min(100, this._width * 1.7);\n\n      // Containers can always grow.\n      if (this.rows) {\n        return overlap;\n      }\n\n      // Rows can grow if they have leaves.\n      if (this.leaves) {\n        return this.leaves.length > 0 ? overlap : noOverlap;\n      }\n\n      // Leaves can grow unless they're the last item in a row.\n      var leaves = this.row.leaves;\n\n      var index = leaves.indexOf(this);\n      return index === leaves.length - 1 ? noOverlap : overlap;\n    }\n  }, {\n    key: 'xOffset',\n    get: function get() {\n      // Containers have no offset.\n      if (this.rows) {\n        return 0;\n      }\n\n      // Rows always start where their container ends.\n      if (this.leaves) {\n        return this.container._width;\n      }\n\n      // Leaves are spread out evenly on the space left by its row.\n      var _row = this.row,\n          leaves = _row.leaves,\n          xOffset = _row.xOffset,\n          _width = _row._width;\n\n      var index = leaves.indexOf(this) + 1;\n      return xOffset + index * _width;\n    }\n  }]);\n\n  return Event;\n}();\n\n/**\n * Return start and end dates with respect to timeslot positions.\n */\n\n\nfunction normalizeDates(startDate, endDate, _ref) {\n  var min = _ref.min,\n      showMultiDayTimes = _ref.showMultiDayTimes;\n\n  if (!showMultiDayTimes) {\n    return [startDate, endDate];\n  }\n\n  var current = new Date(min); // today at midnight\n  var c = new Date(current);\n  var s = new Date(startDate);\n  var e = new Date(endDate);\n\n  // Use noon to compare dates to avoid DST issues.\n  s.setHours(12, 0, 0, 0);\n  e.setHours(12, 0, 0, 0);\n  c.setHours(12, 0, 0, 0);\n\n  // Current day is at the start, but it spans multiple days,\n  // so we correct the end.\n  if (+c === +s && c < e) {\n    return [startDate, _dates2.default.endOf(startDate, 'day')];\n  }\n\n  // Current day is in between start and end dates,\n  // so we make it span all day.\n  if (c > s && c < e) {\n    return [current, _dates2.default.endOf(current, 'day')];\n  }\n\n  // Current day is at the end of a multi day event,\n  // so we make it start at midnight, and end normally.\n  if (c > s && +c === +e) {\n    return [current, endDate];\n  }\n\n  return [startDate, endDate];\n}"]},"metadata":{},"sourceType":"script"}